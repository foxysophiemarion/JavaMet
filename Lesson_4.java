/*
 * ПОДРАЗРЯДНЫЕ ОПЕРАЦИИ
 */
public class Lesson_4 {
	public static void main(String[] args) {
		// Поразрядные операции выполняются над отдельными разрядами или битами чисел. В
		// данных операциях в качестве операндов могут выступать только целые числа.

		// Каждое число имеет определенное двоичное представление. Например, число 4 в
		// двоичной системе 100, а число 5 - 101 и так далее.

		// К примеру, возьмем следующие переменные:
		// byte b = 7;
		// short s = 7;
		// System.out.println(b); // 0000 0111
		// System.out.println(s); // 0000 0000 0000 0111
		// Тип byte занимает 1 байт или 8 бит, соответственно представлен 8 разрядами.
		// Поэтому значение переменной b в двоичном коде будет равно 00000111.
		// Тип short занимает в памяти 2 байта или 16 бит, поэтому число данного типа
		// будет
		// представлено 16 разрядами. И в данном случае переменная s в двоичной системе
		// будет иметь значение 0000 0000 0000 0111.

		// Для записи чисел со знаком в Java применяется дополнительный код (two's
		// complement), при котором старший разряд является знаковым. Если его значение
		// равно 0, то число положительное, и его двоичное представление не отличается
		// от представления беззнакового числа. Например, 0000 0001 в десятичной системе
		// 1.

		// Если старший разряд равен 1, то мы имеем дело с отрицательным числом.
		// Например, 1111 1111 в десятичной системе представляет -1. Соответственно,
		// 1111 0011 представляет -13.

		/*
		 * ЛОГИЧЕСКИЕ ОПЕРАЦИИ
		 */

		// Логические операции над числами представляют поразрядные операции. В данном
		// случае числа рассматриваются в двоичном представлении, например, 2 в двоичной
		// системе равно 10 и имеет два разряда, число 7 - 111 и имеет три разряда.

		// & (логическое умножение)
		// Умножение производится поразрядно, и если у обоих операндов значения разрядов
		// равно 1, то операция возвращает 1, иначе возвращается число 0. Например:
		// int a1 = 2; // 010
		// int b1 = 5; // 101
		// System.out.println(a1 & b1); // результат 0
		// int a2 = 4; // 100
		// int b2 = 5; // 101
		// System.out.println(a2 & b2); // результат 4
		// В первом случае у нас два числа 2 и 5. 2 в двоичном виде представляет число
		// 010, а 5 - 101. Поразрядное умножение чисел (0*1, 1*0, 0*1) дает результат
		// 000.
		// Во втором случае у нас вместо двойки число 4, у которого в первом разряде 1,
		// так же как и у числа 5, поэтому здесь результатом операции (1*1, 0*0, 0 *1) =
		// 100 будет число 4 в десятичном формате.

		// | (логическое сложение)
		// Данная операция также производится по двоичным разрядам, но теперь
		// возвращается единица, если хотя бы у одного числа в данном разряде имеется
		// единица (операция "логическое ИЛИ"). Например:
		// int a1 = 2; // 010
		// int b1 = 5; // 101
		// System.out.println(a1 | b1); // 7 - 111
		// int a2 = 4; // 100
		// int b2 = 5; // 101
		// System.out.println(a2 | b2); // 5 - 101

		// ^ (логическое исключающее ИЛИ)
		// Также эту операцию называют XOR, нередко ее применяют для простого
		// шифрования:
		// int number = 45; // 1001 Значение, которое надо зашифровать - в двоичной
		// форме 101101
		// int key = 102; // Ключ шифрования - в двоичной системе 1100110
		// int encrypt = number ^ key; // Результатом будет число 1001011 или 75
		// System.out.println("Зашифрованное число: " + encrypt);
		// int decrypt = encrypt ^ key; // Результатом будет исходное число 45
		// System.out.println("Расшифрованное число: " + decrypt);
		// Здесь также производятся поразрядные операции. Если у нас значения текущего
		// разряда у обоих чисел разные, то возвращается 1, иначе возвращается 0.
		// Например, результатом выражения 9^5 будет число 12. А чтобы расшифровать
		// число, мы применяем обратную операцию к результату.4

		// ~ (логическое отрицание)
		// Поразрядная операция, которая инвертирует все разряды числа: если значение
		// разряда равно 1, то оно становится равным нулю, и наоборот.
		// byte a = 12; // 0000 1100
		// System.out.println(~a); // 1111 0011 или -13

		// Операции сдвига также производятся над разрядами чисел. Сдвиг может
		// происходить вправо и влево.

		// a<<b - сдвигает число a влево на b разрядов. Например, выражение 4<<1
		// сдвигает число 4 (которое в двоичном представлении 100) на один разряд влево,
		// в результате получается число 1000 или число 8 в десятичном представлении.

		// a>>b - смещает число a вправо на b разрядов. Например, 16>>1 сдвигает число
		// 16 (которое в двоичной системе 10000) на один разряд вправо, то есть в итоге
		// получается 1000 или число 8 в десятичном представлении.

		// a>>>b - в отличие от предыдущих типов сдвигов данная операция представляет
		// беззнаковый сдвиг - сдвигает число a вправо на b разрядов. Например,
		// выражение -8>>>2 будет равно 1073741822.

		// Таким образом, если исходное число, которое надо сдвинуть в ту или другую
		// сторону, делится на два, то фактически получается умножение или деление на
		// два. Поэтому подобную операцию можно использовать вместо непосредственного
		// умножения или деления на два, так как операция сдвига на аппаратном уровне
		// менее дорогостоящая операция в отличие от операции деления или умножения.
		// int a = 4;
		// int b = 2;
		// int c = -8;
		// int d = 2;
		// System.out.println(a << b); // 16
		// System.out.println(a >> b); // 1
		// System.out.println(c >>> d); // 1073741822
	}
}
